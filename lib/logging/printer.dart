import 'dart:convert';
import 'dart:math';

import 'package:logger/logger.dart';
import 'package:stack_trace/stack_trace.dart';

import 'log_message.dart';

const bool _kReleaseMode = bool.fromEnvironment('dart.vm.product');

/// A custom pretty printer that fixes the issue with error method printing
/// when methodCount is set to zero.
class AllenPrettyPrinter extends LogPrinter {
  static const topLeftCorner = '‚îå';
  static const bottomLeftCorner = '‚îî';
  static const middleCorner = '‚îú';
  static const verticalLine = '‚îÇ';
  static const doubleDivider = '‚îÄ';
  static const singleDivider = '‚îÑ';

  static final Map<Level, AnsiColor> defaultLevelColors = {
    Level.trace: AnsiColor.fg(AnsiColor.grey(0.5)),
    Level.debug: const AnsiColor.none(),
    Level.info: const AnsiColor.fg(12),
    Level.warning: const AnsiColor.fg(208),
    Level.error: const AnsiColor.fg(196),
    Level.fatal: const AnsiColor.fg(199),
  };

  static final Map<Level, String> defaultLevelEmojis = {
    Level.trace: '',
    Level.debug: 'üêõ',
    Level.info: 'üí°',
    Level.warning: '‚ö†Ô∏è',
    Level.error: '‚õî',
    Level.fatal: 'üëæ',
  };

  /// Matches a stacktrace line as generated on Android/iOS devices.
  ///
  /// For example:
  /// * #1      Logger.log (package:logger/src/logger.dart:115:29)
  static final _deviceStackTraceRegex = RegExp(r'#[0-9]+\s+(.+) \((\S+)\)');

  /// Matches a stacktrace line as generated by Flutter web.
  ///
  /// For example:
  /// * packages/logger/src/printers/pretty_printer.dart 91:37
  static final _webStackTraceRegex = RegExp(r'^((packages|dart-sdk)/\S+/)');

  /// Matches a stacktrace line as generated by browser Dart.
  ///
  /// For example:
  /// * dart:sdk_internal
  /// * package:logger/src/logger.dart
  static final _browserStackTraceRegex = RegExp(
    r'^(?:package:)?(dart:\S+|\S+)',
  );

  static DateTime? startTime;

  /// The index at which the stack trace should start.
  ///
  /// This can be useful if, for instance, Logger is wrapped in another class and
  /// you wish to remove these wrapped calls from stack trace
  ///
  /// See also:
  /// * [excludePaths]
  final int stackTraceBeginIndex;

  /// Controls the method count in stack traces
  /// when no [LogEvent.error] was provided.
  ///
  /// In case no [LogEvent.stackTrace] was provided,
  /// [StackTrace.current] will be used to create one.
  ///
  /// * Set to `0` in order to disable printing a stack trace
  /// without an error parameter.
  /// * Set to `null` to remove the method count limit all together.
  ///
  /// See also:
  /// * [errorMethodCount]
  final int methodCount;

  /// Controls the method count in stack traces
  /// when [LogEvent.error] was provided.
  ///
  /// In case no [LogEvent.stackTrace] was provided,
  /// [StackTrace.current] will be used to create one.
  ///
  /// * Set to `0` in order to disable printing a stack trace
  /// in case of an error parameter.
  /// * Set to `null` to remove the method count limit all together.
  ///
  /// See also:
  /// * [methodCount]
  final int? errorMethodCount;

  /// Controls the length of the divider lines.
  final int lineLength;

  /// Whether ansi colors are used to color the output.
  final bool colors;

  /// Whether emojis are prefixed to the log line.
  final bool printEmojis;

  /// Controls the format of [LogEvent.time].
  final DateTimeFormatter dateTimeFormat;

  /// Controls the ascii 'boxing' of different [Level]s.
  ///
  /// By default all levels are 'boxed',
  /// to prevent 'boxing' of a specific level,
  /// include it with `true` in the map.
  final Map<Level, bool> excludeBox;

  /// Whether the implicit `bool`s in [excludeBox] are `true` or `false` by default.
  final bool noBoxingByDefault;

  /// A list of custom paths that are excluded from the stack trace.
  final List<String> excludePaths;

  /// Contains the parsed rules resulting from [excludeBox] and [noBoxingByDefault].
  late final Map<Level, bool> _includeBox;
  String _topBorder = '';
  String _middleBorder = '';
  String _bottomBorder = '';

  /// Controls the colors used for the different log levels.
  final Map<Level, AnsiColor>? levelColors;

  /// Controls the emojis used for the different log levels.
  final Map<Level, String>? levelEmojis;

  /// Whether to attempt class/method name extraction (disabled in release mode)
  final bool _shouldExtractNames = !_kReleaseMode;

  AllenPrettyPrinter({
    this.stackTraceBeginIndex = 1,
    this.methodCount = 0,
    this.errorMethodCount,
    this.lineLength = 120,
    this.colors = true,
    this.printEmojis = true,
    this.dateTimeFormat = DateTimeFormat.none,
    this.excludeBox = const {},
    this.noBoxingByDefault = false,
    this.excludePaths = const [],
    this.levelColors,
    this.levelEmojis,
  }) {
    startTime ??= DateTime.now();

    var doubleDividerLine = StringBuffer();
    var singleDividerLine = StringBuffer();
    for (var i = 0; i < lineLength - 1; i++) {
      doubleDividerLine.write(doubleDivider);
      singleDividerLine.write(singleDivider);
    }

    _topBorder = '$topLeftCorner$doubleDividerLine';
    _middleBorder = '$middleCorner$singleDividerLine';
    _bottomBorder = '$bottomLeftCorner$doubleDividerLine';

    _includeBox = {};
    for (var l in Level.values) {
      _includeBox[l] = !noBoxingByDefault;
    }
    excludeBox.forEach((k, v) => _includeBox[k] = !v);
  }

  @override
  List<String> log(LogEvent event) {
    String? dataStr;
    String messageStr;

    final trace = event.stackTrace ?? StackTrace.current;

    // Extract data if message is LogMessage
    if (event.message case LogMessage message) {
      messageStr = stringifyMessage(message);
      if (message.data != null) {
        dataStr = stringifyMessage(message.data);
      }
    } else {
      messageStr = stringifyMessage(event.message);
    }

    String? stackTraceStr;
    if (event.error != null ||
        event.level == Level.error ||
        event.level == Level.fatal ||
        event.stackTrace != null) {
      if ((errorMethodCount == null || errorMethodCount! > 0)) {
        stackTraceStr = _formatStackTrace(trace, errorMethodCount);
      }
    } else if (methodCount > 0) {
      stackTraceStr = _formatStackTrace(trace, methodCount);
    }

    var errorStr = event.error?.toString();

    String? timeStr;
    if (dateTimeFormat != DateTimeFormat.none) {
      timeStr = getTime(event.time);
    }

    return _formatAndPrint(
      event.level,
      messageStr,
      timeStr,
      errorStr,
      stackTraceStr,
      dataStr,
    );
  }

  /// Formats a stack trace using the stack_trace package
  String? _formatStackTrace(StackTrace? stackTrace, int? methodCount) {
    if (stackTrace == null) return null;

    // Convert to Chain to handle async traces
    final chain = stackTrace is Chain ? stackTrace : Chain.forTrace(stackTrace);

    final StringBuffer buffer = StringBuffer();
    var isFirstChain = true;

    // Process each trace in the chain
    for (final trace in chain.traces) {
      // Filter frames based on excludePaths
      final filteredFrames =
          trace.frames.where((frame) {
            final line = frame.toString();
            if (line.isEmpty) return false;
            if (_discardDeviceStacktraceLine(line)) return false;
            if (_discardWebStacktraceLine(line)) return false;
            if (_discardBrowserStacktraceLine(line)) return false;

            return true;
          }).toList();

      // Skip empty traces
      if (filteredFrames.isEmpty) continue;

      // Apply method count limit if specified
      final frames =
          methodCount != null
              ? filteredFrames.take(methodCount).toList()
              : filteredFrames;

      if (frames.isEmpty) continue;

      // Add chain separator if not the first chain and there are frames to show
      int startingIndex = stackTraceBeginIndex;
      if (!isFirstChain && frames.isNotEmpty) {
        startingIndex = 0;
        buffer.writeln();
        buffer.writeln(
          '‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê asynchronous gap ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó',
        );
      }
      isFirstChain = false;

      // Calculate maximum widths for each column
      var maxMemberWidth = 0;
      var maxLibraryWidth = 0;
      var maxLineWidth = 0;

      for (final frame in frames) {
        final member = frame.member ?? '<anonymous>';
        final library = frame.library;
        final location = '${frame.line}:${frame.column}';

        maxMemberWidth = max(maxMemberWidth, member.length);
        maxLibraryWidth = max(maxLibraryWidth, library.length);
        maxLineWidth = max(maxLineWidth, location.length);
      }

      // Add some padding between columns
      const padding = 2;
      maxMemberWidth += padding;
      maxLibraryWidth += padding;

      // Calculate the width needed for the frame count
      final countWidth = frames.length.toString().length;

      // Format frames with consistent spacing
      for (var i = startingIndex; i < frames.length; i++) {
        final count = i - startingIndex;
        final frame = frames[i];
        final member = (frame.member ?? '<anonymous>').padRight(maxMemberWidth);
        final library = frame.library.padRight(maxLibraryWidth);
        final location = '${frame.line}:${frame.column}'.padRight(maxLineWidth);

        // Format: #X   Member   Library   Line:Column
        buffer.write('#${count.toString().padRight(countWidth)} ');
        buffer.write(member);
        buffer.write(library);
        buffer.write(location);

        if (i != frames.length - 1) {
          buffer.writeln();
        }
      }
    }

    return buffer.toString();
  }

  bool _isInExcludePaths(String segment) {
    for (var element in excludePaths) {
      if (segment.startsWith(element)) {
        return true;
      }
    }
    return false;
  }

  bool _discardDeviceStacktraceLine(String line) {
    var match = _deviceStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    final segment = match.group(2)!;
    if (segment.startsWith('package:logger')) {
      return true;
    }
    return _isInExcludePaths(segment);
  }

  bool _discardWebStacktraceLine(String line) {
    var match = _webStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    final segment = match.group(1)!;
    if (segment.startsWith('packages/logger') ||
        segment.startsWith('dart-sdk/lib')) {
      return true;
    }
    return _isInExcludePaths(segment);
  }

  bool _discardBrowserStacktraceLine(String line) {
    var match = _browserStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    final segment = match.group(1)!;
    if (segment.startsWith('package:logger') || segment.startsWith('dart:')) {
      return true;
    }
    return _isInExcludePaths(segment);
  }

  String getTime(DateTime time) {
    return dateTimeFormat(time);
  }

  Object toEncodableFallback(dynamic object) {
    return object.toString();
  }

  String stringifyMessage(dynamic message) {
    final finalMessage = message is Function ? message() : message;
    if (finalMessage is LogMessage) {
      final buffer = StringBuffer();

      // Extract method name if not provided
      String? methodName = finalMessage.method;
      if (methodName == null && _shouldExtractNames) {
        final callerInfo = _extractCallerInfo(finalMessage.callerStackTrace);
        methodName = callerInfo?.methodName;
      }

      // Build class.method prefix
      buffer.write('[${finalMessage.type}');
      if (methodName != null) {
        buffer.write('.');
        buffer.write(methodName);
      }
      buffer.write('] ');

      buffer.write(finalMessage.message);
      return buffer.toString();
    } else if (finalMessage is Map || finalMessage is Iterable) {
      try {
        return JsonEncoder.withIndent('  ').convert(finalMessage);
      } catch (_) {
        return finalMessage.toString();
      }
    } else {
      return finalMessage.toString();
    }
  }

  AnsiColor _getLevelColor(Level level) {
    AnsiColor? color;
    if (colors) {
      color = levelColors?[level] ?? defaultLevelColors[level];
    }
    return color ?? const AnsiColor.none();
  }

  String _getEmoji(Level level) {
    if (printEmojis) {
      final String? emoji = levelEmojis?[level] ?? defaultLevelEmojis[level];
      if (emoji != null) {
        return '$emoji ';
      }
    }
    return '';
  }

  List<String> _formatAndPrint(
    Level level,
    String message,
    String? time,
    String? error,
    String? stacktrace,
    String? data,
  ) {
    List<String> buffer = [];
    var verticalLineAtLevel = (_includeBox[level]!) ? ('$verticalLine ') : '';
    var color = _getLevelColor(level);
    if (_includeBox[level]!) buffer.add(color(_topBorder));

    if (time != null) {
      buffer.add(color('$verticalLineAtLevel$time'));
      if (_includeBox[level]!) buffer.add(color(_middleBorder));
    }

    var emoji = _getEmoji(level);
    for (var line in message.split('\n')) {
      buffer.add(color('$verticalLineAtLevel$emoji$line'));
    }

    if (data != null) {
      if (_includeBox[level]!) buffer.add(color(_middleBorder));
      for (var line in data.split('\n')) {
        buffer.add(color('$verticalLineAtLevel$line'));
      }
    }
    if (error != null) {
      if (_includeBox[level]!) buffer.add(color(_middleBorder));
      for (var line in error.split('\n')) {
        buffer.add(color('$verticalLineAtLevel$line'));
      }
    }

    if (stacktrace != null) {
      if (_includeBox[level]!) buffer.add(color(_middleBorder));
      for (var line in stacktrace.split('\n')) {
        buffer.add(color('$verticalLineAtLevel$line'));
      }
    }

    if (_includeBox[level]!) buffer.add(color(_bottomBorder));

    return buffer;
  }

  /// Extracts the caller's class and method name from a stack trace
  ({String className, String methodName})? _extractCallerInfo(
    StackTrace stackTrace,
  ) {
    try {
      // Convert to Chain to handle async stack traces
      final chain =
          stackTrace is Chain ? stackTrace : Chain.forTrace(stackTrace);

      // Get the first trace (most recent synchronous trace)
      final trace = chain.traces.first;

      // Find the first frame that's not from the logger
      final frame = trace.frames.firstWhere(
        (frame) =>
            !frame.library.contains('logging.dart') &&
            !frame.library.startsWith('dart:') &&
            frame.member != null,
        orElse: () => trace.frames.first,
      );

      final member = frame.member;
      if (member == null) return null;

      // Parse the member string which is in format: Class.method
      final parts = member.split('.');
      if (parts.length < 2) return null;

      return (
        className: parts[0],
        methodName: parts[1].replaceAll(RegExp(r'[<>()]'), ''),
      );
    } catch (_) {
      return null;
    }
  }
}
